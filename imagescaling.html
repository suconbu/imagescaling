<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<title>Image scaling</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    background-color: #f4f4f4;
  }
  main {
    display: flex;
    flex-flow: row;
    /* justify-content: space-around; */
    min-height: 100vh;
    text-align: center;
  }
  input[type="range"] {
    color: black;
  }
  .content-panel {
    display: flex;
    flex-direction: row;
    box-sizing: border-box;
    padding: 10px;
  }
  .section-panel {
    background-color: #eee;
    margin: 10px;
    padding: 10px;
  }
  .image-container {
    display: flex;
    flex-direction: column;
    background-color: #e4e4e4;
  }
  .image-item {
    background-color: #ddd;
    margin: 10px;
  }
  input[type=checkbox] {
    margin: 5px;
  }
</style>

<main>
  <article id="content-panel" class="content-panel"></article>
</main>

<script>
  const imagePaths = [
    "spaceshuttle.png",
    "notebook.png",
    "fujiya.png",
    "kfc.png",
    "mos.png"
  ];
  // const imagePaths = ["spaceshuttle.png","notebook.png","calbee.gif","fujiya.gif","images.jpg","kao.jpg","kfc.png","mos.png"];
  const resizeFunctionMap = {
    //nearest: {func: resizeByNearest, parameter: null},
    bilinear: {func: resizeByBilinear, parameter: null},
    bicubic: {func: resizeByBiqubic, parameter: null},
    // lanczos2: {func: resizeByLanczos, parameter: 2},
    lanczos3: {func: resizeByLanczos, parameter: 3},
    spline16: {func: resizeBySpline, parameter: 2},
    spline36: {func: resizeBySpline, parameter: 3},
  }
  const resizeRatios = [1.0, 1.3, 1.7, 2.0, 2.3, 2.7, 3.0];

  const sincTable = [];
  const sincIndexScale = 100;

  const baseImage = document.createElement("img");
  let currentImageIndex = 0;
  baseImage.src = "sample/" + imagePaths[currentImageIndex];

  const body = document.getElementsByTagName("body")[0];
  body.addEventListener("click", (e) => {
    if(e.x < window.innerWidth / 2) {
      currentImageIndex = (1 <= currentImageIndex) ? currentImageIndex - 1 : imagePaths.length - 1;
    }
    else {
      currentImageIndex = (currentImageIndex + 1) % imagePaths.length;
    }
    baseImage.src = "sample/" + imagePaths[currentImageIndex];
  }, false);

  const imageContainerMap = {};

  baseImage.addEventListener("load", (e) => {
    (function setupCanvas() {
      console.log("base-image: " + baseImage.width + "x" + baseImage.height)
      setupContentPanel();
      for(type in resizeFunctionMap) {
        const imageContainer = imageContainerMap[type];
        const baseImageCanvas = document.createElement("canvas");
        baseImageCanvas.width = baseImage.width;
        baseImageCanvas.height = baseImage.height;
        baseImageCanvas.getContext("2d").drawImage(baseImage, 0, 0);
        console.group(type);
        console.time("total");
        for(let ratio of resizeRatios) {
          let canvas;
          if(ratio == 1.0) {
            canvas = baseImageCanvas;
          }
          else {
            canvas = createResizedImageCanvas(baseImageCanvas, type, ratio);
          }
          const imageItem = document.createElement("div");
          imageItem.className = "image-item";
          imageItem.appendChild(document.createTextNode("x" + ratio));
          imageItem.appendChild(document.createElement("br"));
          imageItem.appendChild(canvas);
          imageContainer.appendChild(imageItem);
        }
        console.timeEnd("total");
        console.groupEnd(type);
      }
    })();
  }, false);

  (function setupSincTable() {
    console.time("setupFastSin");
    const sEnd = 3 * Math.PI * sincIndexScale;
    sincTable.push(1.0);
    for(let s = 1; s <= sEnd; s++) {
      sincTable.push(Math.sin(s / sincIndexScale * Math.PI) / (s / sincIndexScale * Math.PI));
    }
    console.timeEnd("setupFastSin");
  })();

  function setupContentPanel() {
    const contentPanel = document.getElementById("content-panel");
    contentPanel.innerHTML = "";
    for(let type in resizeFunctionMap) {
      const section = document.createElement("section");
      section.id = type + "-panel";
      section.className = "section-panel";

      const caption = document.createElement("h1");
      caption.appendChild(document.createTextNode(type))
      section.appendChild(caption);

      const container = document.createElement("div");
      container.className = "image-container";
      imageContainerMap[type] = container;
      section.appendChild(container);

      contentPanel.appendChild(section);
    }
  }

  function createResizedImageCanvas(srcCanvas, type, ratio) {
    const dstCanvas = document.createElement("canvas");

    const srcContext = srcCanvas.getContext("2d");
    const dstContext = dstCanvas.getContext("2d");

    const sw = srcCanvas.width, sh = srcCanvas.height;
    const dw = sw * ratio, dh = sh * ratio;
    const srcImageData = srcContext.getImageData(0, 0, sw, sh);
    const dstImageData = dstContext.createImageData(dw, dh);

    const timeLabel = "x" + ratio.toFixed(2);
    console.time(timeLabel);
    resizeFunctionMap[type].func(srcImageData, dstImageData, resizeFunctionMap[type].parameter);
    console.timeEnd(timeLabel);

    dstCanvas.width = dw;
    dstCanvas.height = dh;

    dstContext.putImageData(dstImageData, 0, 0);

    return dstCanvas;
  }

  function resizeByNearest(src, dst) {
    const sw = src.width, sh = src.height;
    const dw = dst.width, dh = dst.height;
    const wr = sw / dw, hr = sh / dh;
    for(let dy = 0; dy < dh; dy++) {
      const sy = Math.min(Math.round(hr * dy), sh - 1);

      for(let dx = 0; dx < dw; dx++) {
        const sx = Math.min(Math.round(wr * dx), sw - 1);

        const si = (sy * sw + sx) * 4;
        const di = (dy * dw + dx) * 4;
        dst.data[di + 0] = src.data[si + 0];
        dst.data[di + 1] = src.data[si + 1];
        dst.data[di + 2] = src.data[si + 2];
        dst.data[di + 3] = src.data[si + 3];
      }
    }
  }

  function resizeByBilinear(src, dst) {
    resizeByFunc(src, dst, 1, (d) => (d <= 1) ? (1 - d) : 0);
  }

  function resizeByBiqubic(src, dst) {
    resizeByFunc(src, dst, 2, (d, n) =>
      (d <= 1) ? (((d - 2) * d) * d) + 1 :
      (d <= 2) ? (((-d + 5) * d - 8) * d) + 4 :
      0
    );
  }

  function resizeByLanczos(src, dst, n) {
    // https://www.rainorshine.asia/2015/10/12/post2602.html
    resizeByFunc(src, dst, n, (d, n) =>
      (d == 0) ? 1 :
      (d < n) ? (sincTable[Math.floor(d * sincIndexScale)] * sincTable[Math.floor(d / n * sincIndexScale)]) :
      0
    );
  }

  function resizeBySpline(src, dst, n) {
    // https://www.rainorshine.asia/2015/10/12/post2602.html
    if(n == 3) {
      resizeByFunc(src, dst, n, (d, n) =>
        (d < 1) ? (((247.0 * d - 453.0) * d - 3.0) * d + 209.0) / 209.0 :
        (d < 2) ? (((-114.0 * d + 612.0) * d - 1038.0) * d + 540.0) / 209.0 :
        (d < 3) ? (((19.0 * d - 159.0) * d + 434.0) * d - 384.0) / 209.0 :
        0
      );
    }
    else if(n == 2) {
      resizeByFunc(src, dst, n, (d, n) =>
        (d < 1) ? (((5.0 * d - 9.0) * d - 1.0) * d + 5.0) / 5.0 :
        (d < 2) ? (((-5.0 * d + 27.0) * d - 46.0) * d + 24.0) / 15.0 :
        0
      );
    }
    else {
      console.error("Unsupported!! -> n:" + n);
    }
  }

  // リサイズ処理の共通部
  function resizeByFunc(src, dst, n, func) {
    const sw = src.width, sh = src.height;
    const dw = dst.width, dh = dst.height;
    const wr = sw / dw, hr = sh / dh;

    for(let dy = 0; dy < dh; dy++) {
      const sy = hr * dy;
      const y = Math.floor(sy);

      for(let dx = 0; dx < dw; dx++) {
        const sx = wr * dx;
        const x = Math.floor(sx);

        let r = 0.0, g = 0.0, b = 0.0, a = 0.0;
        let wsum = 0.0;
        for(let ry = y - n + 1; ry <= y + n; ry++) {
          for(let rx = x - n + 1; rx <= x + n; rx++) {
            const wx = func(Math.abs(rx - sx), n);
            const wy = func(Math.abs(ry - sy), n);
            const w = wx * wy;
            if(w != 0) {
              const ssx = (0 <= rx && rx < sw) ? rx : x;
              const ssy = (0 <= ry && ry < sh) ? ry : y;
              const ssi = (ssy * sw + ssx) * 4;
              r += src.data[ssi + 0] * w;
              g += src.data[ssi + 1] * w;
              b += src.data[ssi + 2] * w;
              a += src.data[ssi + 3] * w;
              wsum += w;
            }
          }
        }

        const di = (dy * dw + dx) * 4;
        dst.data[di + 0] = Math.max(0, Math.min(r / wsum, 255));
        dst.data[di + 1] = Math.max(0, Math.min(g / wsum, 255));
        dst.data[di + 2] = Math.max(0, Math.min(b / wsum, 255));
        dst.data[di + 3] = Math.max(0, Math.min(a / wsum, 255));
      }
    }
  }
</script>
