<!doctype html>
<html lang="en">
<meta charset="utf-8"/>
<title>image scaling</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    background-color: #f4f4f4;
  }
  /* main {
    display: flex;
    flex-flow: row;
    min-height: 100vh;
  } */
  input[type="range"] {
    color: black;
  }
  .control-panel {
    visibility: hidden;
    position: fixed;
    /* flex: 0 0 300px; */
    width: 300px;
    min-height: 400px;
    background-color: #e0e0e0;
    box-sizing: border-box;
    padding: 5px;
    margin: 20px;
    border: 1px solid #ccc;
  }
  .content-panel {
    /* flex: 1 1 auto; */
    display: flex;
    flex-direction: row;
    box-sizing: border-box;
    padding: 10px;
    text-align: left;
  }
  .section-panel {
    background-color: #eee;
    margin: 10px;
    padding: 10px;
  }
  .image-container {
    display: flex;
    flex-direction: column;
    background-color: #e4e4e4;
  }
  .image-item {
    background-color: #ddd;
    margin: 10px;
  }
  canvas {
    background-color: white;
  }
</style>

<main>
  <section class="control-panel">
    <ul>
      <li>Filter</li>
      <label><input type="radio" value="nearest" checked/>Nearest neighbor</label><br>
      <label><input type="radio" value="bilinear"/>Bilinear</label>
      <li>Scale</li>
      <div style="vertical-align: middle;">
        <input id="range1" type="range"/><input type="text" style="width: 50px;"/>
      </div>
      <input id="range2" type="range"/>
    </ul>
  </section>
  <article id="content-panel" class="content-panel">
    <!-- <section id="nearest-panel" class="section-panel">
      <h1>Nearest neighbor</h1>
      <div id="nearest-image-container" class="image-container"></div>
    </section>
    <section id="bilinear-panel" class="section-panel">
      <h1>Bilinear</h1>
      <div id="bilinear-image-container" class="image-container"></div>
    </section> -->
  </article>
</main>

<script>
  const imagePaths = ["test.png","spaceshuttle.png","cupcake.png","orange.png","notebook.png","calbee.gif","fujiya.gif","images.jpg","kao.jpg","kfc.png","mos.png"];
  const types = ["nearest", "bilinear", "bicubic", "lanczos3"];
  const resizeFunctionMap = {
    nearest: {func: resizeByNearest, parameter: null},
    bilinear: {func: resizeByBilinear, parameter: null},
    bicubic: {func: resizeByBiqubic, parameter: null},
    lanczos2: {func: resizeByRanczos, parameter: 2},
    lanczos3: {func: resizeByRanczos, parameter: 3}
  }
  const resizeRatios = [1.0, 1.3, 1.7, 2.0, 2.3];

  const baseImage = document.createElement("img");
  let currentImageIndex = 0;
  baseImage.src = "sample/" + imagePaths[currentImageIndex];

  const contentPanel = document.getElementById("content-panel");
  contentPanel.addEventListener("click", (e) => {
    if(e.x < window.innerWidth / 2) {
      currentImageIndex = (1 <= currentImageIndex) ? currentImageIndex - 1 : imagePaths.length - 1;
    }
    else {
      currentImageIndex = (currentImageIndex + 1) % imagePaths.length;
    }
    baseImage.src = "sample/" + imagePaths[currentImageIndex];
  }, false);

  const imageContainerMap = {};

  baseImage.addEventListener("load", (e) => {
    (function setupCanvas() {
      console.log("base-image: " + baseImage.width + "x" + baseImage.height)
      contentPanel.innerHTML = "";
      setupContentPanel();
      for(type of types) {
        const imageContainer = imageContainerMap[type];
        const baseImageCanvas = document.createElement("canvas");
        baseImageCanvas.width = baseImage.width;
        baseImageCanvas.height = baseImage.height;
        baseImageCanvas.getContext("2d").drawImage(baseImage, 0, 0);
        for(let ratio of resizeRatios) {
          let canvas;
          if(ratio == 1.0) {
            canvas = baseImageCanvas;
          }
          else {
            canvas = createResizedImageCanvas(baseImageCanvas, type, ratio);
          }
          const imageItem = document.createElement("div");
          imageItem.className = "image-item";
          imageItem.appendChild(document.createTextNode("x" + ratio));
          imageItem.appendChild(document.createElement("br"));
          imageItem.appendChild(canvas);
          imageContainer.appendChild(imageItem);
        }
      }
    })();
  }, false);

  function setupContentPanel() {
    for(let type of types) {
      const section = document.createElement("section");
      section.id = type + "-panel";
      section.className = "section-panel";

      const caption = document.createElement("h1");
      caption.appendChild(document.createTextNode(type))
      section.appendChild(caption);

      const container = document.createElement("div");
      container.className = "image-container";
      imageContainerMap[type] = container;
      section.appendChild(container);

      contentPanel.appendChild(section);
    }
  }

  function createResizedImageCanvas(srcCanvas, type, ratio) {
    const dstCanvas = document.createElement("canvas");

    const srcContext = srcCanvas.getContext("2d");
    const dstContext = dstCanvas.getContext("2d");

    const sw = srcCanvas.width, sh = srcCanvas.height;
    const dw = sw * ratio, dh = sh * ratio;
    const srcImageData = srcContext.getImageData(0, 0, sw, sh);
    const dstImageData = dstContext.createImageData(dw, dh);

    const timeLabel = type + " - x" + ratio.toFixed(2);
    console.time(timeLabel);
    resizeFunctionMap[type].func(srcImageData, dstImageData, resizeFunctionMap[type].parameter);
    console.timeEnd(timeLabel);

    dstCanvas.width = dw;
    dstCanvas.height = dh;

    dstContext.putImageData(dstImageData, 0, 0);

    return dstCanvas;
  }

  function resizeByNearest(src, dst) {
    const sw = src.width, sh = src.height;
    const dw = dst.width, dh = dst.height;
    const wr = sw / dw, hr = sh / dh;
    for(let dy = 0; dy < dh; dy++) {
      const sy = Math.min(Math.round(hr * dy), sh - 1);

      for(let dx = 0; dx < dw; dx++) {
        const sx = Math.min(Math.round(wr * dx), sw - 1);

        const si = (sy * sw + sx) * 4;
        const di = (dy * dw + dx) * 4;
        dst.data[di + 0] = src.data[si + 0];
        dst.data[di + 1] = src.data[si + 1];
        dst.data[di + 2] = src.data[si + 2];
        dst.data[di + 3] = src.data[si + 3];
      }
    }
  }

  function resizeByBilinear(src, dst) {
    resizeByFunc(src, dst, (src, dst, dx, dy, sx, sy, sw, sh) => {
      let r = 0.0, g = 0.0, b = 0.0, a = 0.0;
      let wsum = 0.0;
      const x = Math.floor(sx);
      const y = Math.floor(sy);
      for(let ry = y; ry <= y + 1; ry++) {
        for(let rx = x; rx <= x + 1; rx++) {
          const xd = Math.abs(rx - sx);
          const yd = Math.abs(ry - sy);
          const wx = xd <= 1 ? 1 - xd : 0;
          const wy = yd <= 1 ? 1 - yd : 0;
          const w = wx * wy;
          if(w != 0) {
            const ssx = (0 <= rx && rx < sw) ? rx : x;
            const ssy = (0 <= ry && ry < sh) ? ry : y;
            const ssi = (ssy * sw + ssx) * 4;
            r += src.data[ssi + 0] * w;
            g += src.data[ssi + 1] * w;
            b += src.data[ssi + 2] * w;
            a += src.data[ssi + 3] * w;
            wsum += w;
          }
        }
      }
      return {
        r: Math.max(0, Math.min(r / wsum, 255)),
        g: Math.max(0, Math.min(g / wsum, 255)),
        b: Math.max(0, Math.min(b / wsum, 255)),
        a: Math.max(0, Math.min(a / wsum, 255))
      };
    });
  }

  function resizeByBilinearFast(src, dst) {
    // https://www.rainorshine.asia/2008/05/16/post428.html
    const sw = src.width, sh = src.height;
    const dw = dst.width, dh = dst.height;
    const wr = sw / dw, hr = sh / dh;
    for(let dy = 0; dy < dh; dy++) {
      const sy = hr * dy;
      const y0 = Math.floor(sy);
      const y1 = Math.min(y0 + 1, sh - 1);
      const cy1 = sy - y0;
      const cy0 = 1 - cy1;

      for(let dx = 0; dx < dw; dx++) {
        const sx = wr * dx;
        const x0 = Math.floor(sx);
        const x1 = Math.min(x0 + 1, sw - 1);
        const cx1 = sx - x0;
        const cx0 = 1 - cx1;

        const si00 = (y0 * sw + x0) * 4;
        const si01 = (y1 * sw + x0) * 4;
        const si10 = (y0 * sw + x1) * 4;
        const si11 = (y1 * sw + x1) * 4;

        const r0 = src.data[si00 + 0] * cx0 + src.data[si10 + 0] * cx1;
        const r1 = src.data[si01 + 0] * cx0 + src.data[si11 + 0] * cx1;
        const g0 = src.data[si00 + 1] * cx0 + src.data[si10 + 1] * cx1;
        const g1 = src.data[si01 + 1] * cx0 + src.data[si11 + 1] * cx1;
        const b0 = src.data[si00 + 2] * cx0 + src.data[si10 + 2] * cx1;
        const b1 = src.data[si01 + 2] * cx0 + src.data[si11 + 2] * cx1;
        const a0 = src.data[si00 + 3] * cx0 + src.data[si10 + 3] * cx1;
        const a1 = src.data[si01 + 3] * cx0 + src.data[si11 + 3] * cx1;

        const di = (dy * dw + dx) * 4;
        dst.data[di + 0] = Math.min(255, Math.round(r0 * cy0 + r1 * cy1));
        dst.data[di + 1] = Math.min(255, Math.round(g0 * cy0 + g1 * cy1));
        dst.data[di + 2] = Math.min(255, Math.round(b0 * cy0 + b1 * cy1));
        dst.data[di + 3] = Math.min(255, Math.round(a0 * cy0 + a1 * cy1));
      }
    }
  }

  function resizeByBiqubic(src, dst) {
    resizeByFunc(src, dst, (src, dst, dx, dy, sx, sy, sw, sh) => {
      let r = 0.0, g = 0.0, b = 0.0, a = 0.0;
      let wsum = 0.0;
      const x = Math.floor(sx);
      const y = Math.floor(sy);
      for(let ry = y - 1; ry <= y + 2; ry++) {
        for(let rx = x - 1; rx <= x + 2; rx++) {
          const xd = Math.abs(rx - sx);
          const yd = Math.abs(ry - sy);
          const wx = (xd <= 1) ? (1 - 2 * (xd * xd) + (xd * xd * xd)) :
            (xd <= 2) ? (4 - 8 * xd + 5 * (xd * xd) - (xd * xd * xd)) :
            0;
          const wy = (yd <= 1) ? (1 - 2 * (yd * yd) + (yd * yd * yd)) :
            (yd <= 2) ? (4 - 8 * yd + 5 * (yd * yd) - (yd * yd * yd)) :
            0;
          const w = wx * wy;
          if(w != 0) {
            const ssx = (0 <= rx && rx < sw) ? rx : x;
            const ssy = (0 <= ry && ry < sh) ? ry : y;
            const ssi = (ssy * sw + ssx) * 4;
            r += src.data[ssi + 0] * w;
            g += src.data[ssi + 1] * w;
            b += src.data[ssi + 2] * w;
            a += src.data[ssi + 3] * w;
            wsum += w;
          }
        }
      }
      return {
        r: Math.max(0, Math.min(r / wsum, 255)),
        g: Math.max(0, Math.min(g / wsum, 255)),
        b: Math.max(0, Math.min(b / wsum, 255)),
        a: Math.max(0, Math.min(a / wsum, 255))
      };
    });
  }

  function resizeByRanczos(src, dst, n) {
    resizeByFunc(src, dst, (src, dst, dx, dy, sx, sy, sw, sh) => {
      let r = 0.0, g = 0.0, b = 0.0, a = 0.0;
      let wsum = 0.0;
      const x = Math.floor(sx);
      const y = Math.floor(sy);
      for(let ry = y - n + 1; ry <= y + n; ry++) {
        for(let rx = x - n + 1; rx <= x + n; rx++) {
          const xd = Math.abs(rx - sx);
          const yd = Math.abs(ry - sy);
          const wx = (xd == 0) ? 1 :
            xd < n ? (Math.sin(xd * Math.PI) / (xd * Math.PI) * Math.sin((xd / n) * Math.PI) / ((xd / n) * Math.PI)) :
            0;
          const wy = (yd == 0) ? 1 :
            yd < n ? (Math.sin(yd * Math.PI) / (yd * Math.PI) * Math.sin((yd / n) * Math.PI) / ((yd / n) * Math.PI)) :
            0;
          const w = wx * wy;
          if(w != 0) {
            const ssx = (0 <= rx && rx < sw) ? rx : x;
            const ssy = (0 <= ry && ry < sh) ? ry : y;
            const ssi = (ssy * sw + ssx) * 4;
            r += src.data[ssi + 0] * w;
            g += src.data[ssi + 1] * w;
            b += src.data[ssi + 2] * w;
            a += src.data[ssi + 3] * w;
            wsum += w;
          }
        }
      }
      return {
        r: Math.max(0, Math.min(r / wsum, 255)),
        g: Math.max(0, Math.min(g / wsum, 255)),
        b: Math.max(0, Math.min(b / wsum, 255)),
        a: Math.max(0, Math.min(a / wsum, 255))
      };
    });
  }

  function resizeByFunc(src, dst, func) {
    const sw = src.width, sh = src.height;
    const dw = dst.width, dh = dst.height;
    const wr = sw / dw, hr = sh / dh;

    const n = 1;

    for(let dy = 0; dy < dh; dy++) {
      const sy = hr * dy;
      const y = Math.floor(sy);

      for(let dx = 0; dx < dw; dx++) {
        const sx = wr * dx;
        const x = Math.floor(sx);

        const rgba = func(src, dst, dx, dy, sx, sy, sw, sh);

        const di = (dy * dw + dx) * 4;
        dst.data[di + 0] = rgba.r;
        dst.data[di + 1] = rgba.g;
        dst.data[di + 2] = rgba.b;
        dst.data[di + 3] = rgba.a;
      }
    }
  }

  // function resizeByWeightFuncX(src, dst, n, func) {
  //   // https://www.rainorshine.asia/2015/10/12/post2602.html
  //   const sw = src.width, sh = src.height;
  //   const dw = dst.width, dh = dst.height;
  //   const wr = sw / dw, hr = sh / dh;

  //   for(let dy = 0; dy < dh; dy++) {
  //     // const sy = hr * (dy - 0.5);
  //     // const y = Math.round(sy);
  //     const sy = hr * dy;
  //     const y = Math.floor(sy);

  //     for(let dx = 0; dx < dw; dx++) {
  //       // const sx = wr * (dx - 0.5);
  //       // const x = Math.round(sx);
  //       const sx = wr * dx;
  //       const x = Math.floor(sx);
  //       let r = 0.0, g = 0.0, b = 0.0, a = 0.0;

  //       let ww = 0;
  //       for(let ry = y - n + 1; ry <= y + n; ry++) {
  //         for(let rx = x - n + 1; rx <= x + n; rx++) {
  //           const wx = func(sx - rx, n);
  //           const wy = func(sy - ry, n);
  //           const w = wx * wy;
  //           if(w != 0) {
  //             const ssx = (0 <= rx && rx < sw) ? rx : x;
  //             const ssy = (0 <= ry && ry < sh) ? ry : y;
  //             const ssi = (ssy * sw + ssx) * 4;
  //             r += src.data[ssi + 0] * w;
  //             g += src.data[ssi + 1] * w;
  //             b += src.data[ssi + 2] * w;
  //             a += src.data[ssi + 3] * w;
  //             ww += w;
  //           }
  //         }
  //       }

  //       const di = (dy * dw + dx) * 4;
  //       dst.data[di + 0] = Math.max(0, Math.min(255, r / ww));
  //       dst.data[di + 1] = Math.max(0, Math.min(255, g / ww));
  //       dst.data[di + 2] = Math.max(0, Math.min(255, b / ww));
  //       dst.data[di + 3] = Math.max(0, Math.min(255, a / ww));
  //     }
  //   }
  // }
</script>
